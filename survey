#!/usr/bin/env python
#
# Copyright (c) 2015 Catalyst.net Ltd
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#

"""
dns-survey - Produce an sqlite database of sniffed DNS rrnames grouped by hour.

Michael Fincham <michael.fincham@catalyst.net.nz>
"""

#import argparse
import datetime
import logging
import sys

import sqlite3
from scapy.layers.dns import DNS, DNSRR
from scapy.sendrecv import sniff

class AnswerCounter(object):
    DEFAULT_DATABASE_PATH = 'survey.sqlite3'
    DEFAULT_PACKET_COUNT_INTERVAL = 100

    def __init__(self, database_path=DEFAULT_DATABASE_PATH, packet_count_interval=DEFAULT_PACKET_COUNT_INTERVAL):
        self.database_path = database_path
        self.packet_count_interval = packet_count_interval
        self.totals = {}
        self.packet_count = 0
        logging.info('using database "%s"' % self.database_path)

        try:
            self.conn = sqlite3.connect(self.database_path)
            self.conn.execute(
                "create table if not exists rrnames(rrname TEXT, hour INTEGER, count INTEGER, UNIQUE(rrname, hour));"
            )
        except:
            logging.error('unable to open database "%s"' % self.database_path)
            raise

    def _hour(self):
        return datetime.datetime.now().replace(minute=0, second=0, microsecond=0)

    def _sniffer_callback(self, packet):
        if packet.haslayer(DNSRR) and packet[DNS].aa == 1:
            rrname = packet[DNSRR].rrname.lower()

            if rrname not in self.totals:
                self.totals[rrname] = 0

            self.totals[rrname] += 1
            self.packet_count += 1

        if self.packet_count == 100:
            logging.info('saving totals to database...')

            try:
                c = self.conn.cursor()

                for rrname, count in self.totals.iteritems():
                    hour = self._hour()
                    c.execute("INSERT OR IGNORE INTO rrnames VALUES (?, ?, 0);", (rrname, hour))
                    c.execute("UPDATE rrnames SET count = count + ? WHERE rrname=? AND hour=?;", (count, rrname, hour))

                self.conn.commit()
                self.packet_count = 0
                self.totals = {}
                logging.info('saved')
            except:
                logging.error('could not save to database')
                raise

    def start_capture(self):
        logging.info('starting sniffer...')
        try:
            sniff(filter="udp and port 53", prn=self._sniffer_callback, store=0)
        except:
            logging.error('could not capture packets')
            raise


if __name__ == "__main__":
    logging.basicConfig(format='%(asctime)s %(message)s', level=logging.INFO)

    counter = AnswerCounter()
    counter.start_capture()
