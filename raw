#!/usr/bin/env python

"""
Raw socket DNS sniffer w/ scapy for decoding. Designed to run on python 2.5 thru 2.7.
Scapy's `sniff' function is too slow on embedded devices, this approach uses considerably less CPU.

Michael Fincham <michael.fincham@catalyst.net.nz>
"""

import socket
import struct
import binascii

from scapy.layers.l2 import Ether
from scapy.layers.dns import DNS, DNSRR, DNSQR

PROTOCOLS = {
    'UDP': 17,
}

raw = socket.socket(socket.AF_PACKET, socket.SOCK_RAW, socket.htons(0x0800)) # ETH_P_IP

while True:

    packet = raw.recvfrom(2048)

    ethernet_header = struct.unpack("!6s6s2s", packet[0][0:14])
    ip_header = struct.unpack('!BBHHHBBH4s4s', packet[0][14:34])

    ihl = ip_header[0] & 0xF
    ip_header_length = ihl * 32 / 8

    ip_version_ihl, ip_dscp_ecn, ip_total_length, ip_identification, \
    ip_flags_fragment_offset, ip_ttl, ip_protocol, ip_header_checksum, \
    ip_source_address, ip_destination_address = ip_header

    if ip_protocol == PROTOCOLS['UDP']:
        udp_source_port, udp_destination_port = struct.unpack('!HH', packet[0][ip_header_length+14:ip_header_length+14+4])

        if udp_source_port == 53:
            print repr(Ether(packet[0])[DNS])
